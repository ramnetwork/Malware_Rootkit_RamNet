import cryptography
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import serialization
import os
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import padding


class generate:
    def pru_k():
        private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=2048,
            backend=default_backend()
            )
        public_key = private_key.public_key()
        # private key
        serial_private = private_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=serialization.NoEncryption()
            )
        os.system("pwd")   
        with open('../../../dat/private.pem', 'wb') as f: f.write(serial_private)
        # public key
        serial_pub = public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
            )
        with open('../../../dat/public.pem', 'wb') as f: f.write(serial_pub)
        ################
        message = b"THIS TEXT IS PRIVATE"
        signature = private_key.sign(
            message,
            padding.PSS(
            mgf=padding.MGF1(hashes.SHA256()),
            salt_length=padding.PSS.MAX_LENGTH
            ),
            hashes.SHA256()
            )


class imported:
    def read_private (filename ):
        with open(filename, "rb") as key_file:
            private_key = serialization.load_pem_private_key(
                key_file.read(),
                password=None,
                backend=default_backend()
            )
        return private_key
                  
    ######### Public (shared) device only ##########
    def read_public (filename ):
        with open(filename, "rb") as key_file:
            public_key = serialization.load_pem_public_key(
                key_file.read(),
                backend=default_backend()
            )
        return public_key    


class cipher:
    def cip(public_key,dat):
        open('../../../sources/key_encripted.dat', "wb").close()
        dat1=dat.encode("ascii")
        ciphertext = public_key.encrypt(
            dat1,
            padding.OAEP(
            mgf=padding.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None
            )
        )
        with open('../../../sources/key_encripted.dat', "ab") as f: f.write(ciphertext)
        return ciphertext
        
